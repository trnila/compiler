options {
  JAVA_UNICODE_ESCAPE = true;
  DEBUG_PARSER = true;
}

PARSER_BEGIN(LangParser)
import java.io.*;

public class LangParser {
	public static void main(String args[]) throws Exception {
		InputStream is;
		if(args.length < 1) {
			is = System.in;
		} else {
			is = new FileInputStream(args[0]);
		}

		LangParser parser = new LangParser(is);
		parser.Program();
	}
}
PARSER_END(LangParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
< BOOLEAN: "boolean" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < FALSE: "False" >
| < FLOAT: "float" >
| < FOR: "for" >
| < IF: "if" >
| < INT: "int" >
| < STRING: "String" >
| < TRUE: "True" >
| < WRITE: "write" >
| < READ: "read" >
| < THEN: "then" >
| < END: "end" >
| < BEGIN: "begin" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         "$",
         "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < SEMICOLON: ";" >
| < COMMA: "," >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < DOT: "." >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

void Program() :
{}
{
	Statements()
  <EOF>
}

void Statements():
{}
{
	(Statement())+
}

/*
 * Declaration syntax follows.
 */

void VariableDeclarator() :
{}
{
  VariableDeclaratorId()
}

void VariableDeclaratorId() :
{}
{
  <IDENTIFIER>
}

/*
 * Type, name and expression syntax follows.
 */

void Type() :
{}
{
    "boolean"
  | "int"
  | "float"
  | "double"
  | "String"
}

/*
 * Expression syntax follows.
 */

void Expression() :
{}
{
	LOOKAHEAD(VariableDeclaratorId() "=") Assignment()
	| ConditionalExpression()
}

void Assignment() :
{}
{
  VariableDeclaratorId() "=" Expression()
}

void ConditionalExpression() :
{}
{
  ConditionalOrExpression() [ "?" Expression() ":" ConditionalExpression() ]
}

void ConditionalOrExpression() :
{}
{
  ConditionalAndExpression() ( "||" ConditionalAndExpression() )*
}

void ConditionalAndExpression() :
{}
{
  InclusiveOrExpression() ( "&&" InclusiveOrExpression() )*
}

void InclusiveOrExpression() :
{}
{
  ExclusiveOrExpression() ( "|" ExclusiveOrExpression() )*
}

void ExclusiveOrExpression() :
{}
{
  AndExpression() ( "^" AndExpression() )*
}

void AndExpression() :
{}
{
  EqualityExpression() ( "&" EqualityExpression() )*
}

void EqualityExpression() :
{}
{
  InstanceOfExpression() ( ( "==" | "!=" ) InstanceOfExpression() )*
}

void InstanceOfExpression() :
{}
{
  RelationalExpression() [ "instanceof" Type() ]
}

void RelationalExpression() :
{}
{
  ShiftExpression() ( ( "<" | ">" | "<=" | ">=" ) ShiftExpression() )*
}

void ShiftExpression() :
{}
{
  AdditiveExpression() ( ( "<<" | ">>" | ">>>" ) AdditiveExpression() )*
}

void AdditiveExpression() :
{}
{
  MultiplicativeExpression() ( ( "+" | "-" | "." ) MultiplicativeExpression() )*
}

void MultiplicativeExpression() :
{}
{
  UnaryExpression() ( ( "*" | "/" | "%" ) UnaryExpression() )*
}

void UnaryExpression() :
{}
{
  ( "+" | "-" ) UnaryExpression()
|
  UnaryExpressionNotPlusMinus()
}

void UnaryExpressionNotPlusMinus() :
{}
{
  ( "~" | "!" ) UnaryExpression()
  | PrimaryPrefix()
}

void PrimaryPrefix() :
{}
{
  Literal()
| VariableDeclaratorId()
| "(" Expression() ")"
}

void Literal() :
{}
{
 <INTEGER_LITERAL>
| <FLOATING_POINT_LITERAL>
| <STRING_LITERAL>
| <TRUE>
| <FALSE>
}

void Arguments() :
{}
{
  "(" [ ArgumentList() ] ")"
}

void ArgumentList() :
{}
{
  Expression() ( "," Expression() )*
}

/*
 * Statement syntax follows.
 */

void Statement() :
{}
{
  ";"
| LocalVariableDeclaration() ";"
| IfStatement()
| ForStatement()
| WriteStatement()
| ReadStatement()
| Expression() ";"
}

void LocalVariableDeclaration() :
{}
{
  Type() VariableDeclarator() ( "," VariableDeclarator() )*
}

void StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{}
{Expression()
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" Expression() <THEN> Statements() [ LOOKAHEAD(<ELSE>) <ELSE> Statements() ] <END> ";"
}

void ForStatement() :
{}
{
  "for" "(" [ ForInit() ] ";" [ Expression() ] ";" [ ForUpdate() ] ")"
   <BEGIN>
    Statements()
   <END>";"
}

void WriteStatement() :
{}
{
	"write" StatementExpressionList() ";"
}

void ReadStatement() :
{}
{
	"read" StatementExpressionList() ";"
}

void ForInit() :
{}
{
  LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList() :
{}
{
  StatementExpression() ( "," StatementExpression() )*
}

void ForUpdate() :
{}
{
  StatementExpressionList()
}